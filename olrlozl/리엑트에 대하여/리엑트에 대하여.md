### ⬛ **React**란?

- React는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리
- 리액트는 인터렉션이 많은 웹 앱을 개발하기 위해서 주로 사용
- 웹 앱을 만드는 다른 Tool인 Vue, Angualar와의 가장 큰 차이점:
    - Vue와 Angualar: **프레임워크**
    - React: **라이브러리**

### ⬛ 프레임워크 vs 라이브러리

- **프레임워크**: 어떠한 앱을 만들기 위해 필요한 대부분의 라이브러리를 가지고 있다
- **라이브러리**: 어떠한 특정 기능을 위해 모듈화 되어있다

![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/44c4fa8c359a6b81e2958af647242b25ee6f5270/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/1.png)

- 프레임 워크는 라이브러리를 포함한다
- 프레임워크는 우리가 작성한 소스 코드를 호출한다
- 소스 코드는 어떠한 기능을 구현하기 위해서 라이브러리를 호출한다

### ⬛ 리엑트는 프레임워크가 아닌 라이브러리인 이유

- 리액트는 전적으로 **UI를 렌더링** 하는 데 관여하기 때문
- 화면을 바꾸는 라우팅은 react-router-dom 모듈을 사용하며, 
상태 관리를 위해서는 redux, mobx, recoil 등 여러 모듈을 사용하며, 
빌드를 위해서는 webpack, npm 등을 이용하며,
테스팅을 위해서는 Eslint, Mocha, Jest 등을 이용하기 때문

### ⬛ **많은 기업에서 리액트를 사용하는 이유**

- 상대적으로 배우기 쉬운 라이브러리
- 여러 기능들을 위해 이미 만들어져 있는 라이브러리 환경
- 많은 기업들의 사용으로 검증이 된 라이브러리 (대표적으로 페이스북)

### ⬛ 컴포넌트(Component)

- **컴포넌트**: 리액트로 만들어진 앱을 이루는 최소한의 단위
- 리액트는 여러 컴포넌트 조각으로 되어있다
- 여러개의 컴포넌트가 모여서 하나의 페이지를 이룬다
- 하나의 컴포넌트를 여러 곳에서 사용할 수 있다
- 리엑트 컴포넌트 2가지
    1. 클래스형 컴포넌트
        
        ```jsx
        class App extends Component {
        	render() {
        		return <h1>안녕하세요</h1>;
        	}
        }
        ```
        
    2. 함수형 컴포넌트
        
        ```jsx
        function App() {
        		return <h1>안녕하세요</h1>;
        }
        ```
        
    3. 클래스형 컴포넌트 VS 함수형 컴포넌트
       
		|           | 클래스형 컴포넌트                                            | 함수형 컴포넌트                                             |
		|:---------------:|-------------------------------------------------------------|------------------------------------------------------------|
		| **선언방식**  | • class 키워드가 반드시 필요하다<br>• React.Component를 상속받아야 한다<br>• render() 메서드를 통해 JSX를 반환한다 | • 일반 함수로 작성하며, 별도의 클래스 상속 없이 구현한다<br>• 선언이 간편하다 |
		| **상태관리**  | • this.state와 this.setState를 사용하여 컴포넌트의 상태를 직접 관리 | • useState Hook을 사용하여 상태 관리                            |
		| **라이프사이클** | • LifeCycle 메서드를 사용하여 컴포넌트의 생성, 업데이트, 제거에 대한 로직을 구현 | • useEffect Hook을 사용하여 라이프사이클 메서드와 유사한 기능 구현 |
		| **장점**      | • 생명주기 메서드를 사용하여 컴포넌트의 상태 변화에 따른 정교한 제어가 가능하다<br>• this 키워드를 통해 컴포넌트의 상태를 직접 관리하여 상태 관리의 명확성을 제공한다 | • 코드가 간결하고 직관적이다<br>• 인스턴스 생성 과정이 없기 때문에 메모리 사용량이 줄어들고, 렌더링 성능이 비교적 좋다 |



### ⬛ Node.js

- 리액트 프로젝트를 만들기 위해서 Node.js와 npm을 먼저 설치해야한다.
- Node.js란 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임으로서, **웹 브라우저 환경이 아닌 곳에서도** 자바스크립트를 사용하여 연산 할 수 있다.
- Node.js는 React를 사용하기 더 쉽게 해주는 도구들을 내장하고 있는 오픈소스이자 JavaScript runtime environment이다.

### ⬛ **React 설치 시 Node.js가 필요한 이유**

리액트 앱은 웹 브라우저에서 실행되는 코드여서 Node.js와 직접적인 연관은 없지만, **프로젝트를 개발하는 데 필요한 바벨(Babel), 웹팩(Webpack)등 주요 도구들이 Node.js를 사용**하기 때문에 필요하다

1. **Node.js는 자바스크립트 실행환경이기 때문**
    - Node.js는 브라우저 말고도 다른 환경에서 자바스크립트를 사용할 수 있게 해준다.
2. **NPM (Node Package Manager)을 사용하기 위해**
    - NPM은 React 개발에 필요한 Node.js에서 사용할 수 있는 **모듈들을 패키지화하여 모아둔 저장소 역할**과 **패키지 설치 및 관리를 위한 CLI(Command Line Interface)를 제공**한다.
    - npm은 Node.js를 설치할 때 함께 설치된다
    - npm을 CLI로 실행시키고 싶다면 Node.js가 필요하다.
3. **JSX를 사용하기 위해**
    - Node.js가 있으면 **바벨(Babel)**이라는 컴파일러 도구를 추가로 다운받아 사용할 수 있다.
    - JSX 사용을 위해서 바벨은 필수다. 바벨을 다운받아, 자바스크립트 대신에 자바스크립트를 확장한 문법인 **JSX**를 사용하는 것이 가능하다!
    - 자바스크립트로만 개발을 하면 가독성과 유지보수가 힘들어지는데, JSX를 이용하면 우리에게 익숙한 html 코드로 개발하여 가독성과 유지보수를 쉽게 해줄 수 있다.
- ⬛ **바벨 (Babel)**
    - 최신 자바스크립트 문법을 지원하지 않는 브라우저들을 위해서, 최신 자바스크립트 문법을 구형 브라우저에서도 돌 수 있게 변환 시켜주는 라이브러리
    - JSX 문법을 브라우저가 해석할 수 없기 때문에 바벨을 이용하여 자바스크립트로 변환해야 한다.
    - 또한, 자바스크립트 es6(ECMAScript)문법을 브라우저에서 동작하도록 하기 위해선 하위버전(es5)의 코드로 변경시켜야 하는데 이때 babel이 사용된다.
- ⬛ **웹팩 (Webpack)**
    
    오픈 소스 자바스크립트 모듈 번들러로써, 여러 개로 나누어져 있는 파일들을 하나의 자바스크립트 코드로 압축하고 최적화하는 라이브러리
    
    **장점**
    
    1. 여러 파일의 자바스크립트 코드를 압축하여 최적화 할 수 있기 때문에, 로딩에 대한 네트워크 비용을 줄일 수 있다
    2. 모듈 단위로 개발이 가능하여, 가독성과 유지보수가 쉽다

### ⬛ 리엑트 설치

**예전에는** Webpack 이나 Babel 같은 모듈을 설치하고 설정해야 리액트 앱을 시작할 수 있었지만,

**요즘에는** `npx create-react-app <폴더 이름>`이라는 명령어로 간단하게 설치할 수 있다. 이렇게 하면 Babel이나 Webpack 설정이 이미 다 되어있기 때문에 많은 시간이 걸리지 않고 리액트 앱을 시작할 수 있다

- 리엑트 앱을 만들 폴더 생성 → 터미널 실행 → `npx create-react-app ./`
- **npx create-react-app ./ 에서 npx는 무엇일까**
    
    **npx**는 노드 패키지 실행을 도와주는 도구이다.
    
    그래서 npm registry (라이브러리들이 저장된 곳) 에 있는 create-react-app 패키지를 리엑트 앱을 만들 폴더에서 실행해서 리액트를 설치 한다
  
 - **npm과 npx**
    - `npm`으로 패키지를 설치하는 방법
        - `전역`으로 패키지를 설치하여 의존성 라이브러리들을 전체적으로 관리
        - 특정 프로젝트에만 필요한 의존성 라이브러리들은 해당 프로젝트의 `로컬`에 설치하여 관리
    - 의존성 라이브러리들이 전역이나 로컬에 설치된 채 관리되면 생기는 **문제점**
        - 전역으로 설치된 패키지는 여러 프로젝트에서 공통으로 사용되기 때문에, 특정 프로젝트에서 요구하는 `버전과 충돌`할 수 있다
        - 로컬 설치의 경우, 프로젝트마다 패키지의 버전을 다르게 관리해야 할 수 있어, `업데이트 시` 번거로움이 있을 수 있다
    - **해결법** ⇒ `npx`
        - 패키지를 `설치하지 않고도` npm 레지스트리에서 `최신 버전`을 다운로드하여 바로 실행할 수 있다
        - 최신 버전을 사용하기 때문에 별도의 업데이트 과정이 필요없다
        - npm 5.2.0 버전 이상 부터 npm을 설치하면 자동으로 npx가 설치된다
  
        | npm | npx |
        |:-----:|:-----:|
        | Node Package Manager, 노드 패키지 `관리자` | Node Package eXecute, 노드 패키지 `실행자` |
        | 1. npm install create-react-app <br> 2. create-react-app myApp  <br> ⇒ 설치 필요 | 1. npx create-react-app myApp <br> ⇒ 설치하지 않고 사용 가능 |
    

### ⬛ **브라우저가 그려지는 원리 및 가상돔**

- 리액트의 주요 특징 중 하나는 **가상 돔(Virtual DOM)**을 사용한다는 것!
- 실제 돔(Real DOM)?
- 브라우저가 렌더링하는 과정?

### ⬛ 돔 (DOM, Document Object Model)

브라우저에서 요소(Element)들로 구성된 HTML을 이용해서 화면에 UI를 표현할 수 있는데,

웹 페이지를 이루는 요소들을 자바스크립트가 이용할 수 있게끔 브라우저가 **트리구조로 만든 객체 모델**을 의미한다

![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/8bd843fc09ae695978039c153ef3a3168de7264a/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/2.png)


### ⬛ DOM 조작

DOM 트리를 DOM 에서 제공해주는 API를 이용해서 조작할 수 있다

DOM 구조에 접근하거나 원하는 요소(Element)를 수정하거나 없애거나 할 수 있다

```jsx
// DOM 안에 button이라는 클래스 이름을 가진 요소에 접근
var button = document.querySelector('.button');

// DOM 안에 있는 요소의 스타일을 직접 변경 (DOM 조작)
button.onclick = function() {
	this.style.backgroundColor = "red";
};
```

이렇게 DOM을 조작해서 화면을 변경시켜줄 때 브라우저 내부에서는 어떠한 과정을 통해서 바뀐 화면을 변경시켜줄까?

### ⬛ 웹 페이지 빌드 과정 (Critical Rendering Path, CRP)

브라우저가 서버에서 페이지에 대한 HTML 응답을 받고 **화면에 표시하기 전에 여러 단계**가 있다

웹 브라우저가 HTML 문서를 읽고, 스타일 입히고 뷰포트에 표시하는 과정이다

![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/44c4fa8c359a6b81e2958af647242b25ee6f5270/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/3.png)

1. **DOM tree 생성**
    
    렌더 엔진이 문서를 읽어들여서 그것들을 파싱하고 어떤 내용을 페이지에 렌더링할 지 결정한다
    
2. **Render tree 생성**
    
    브라우저가 DOM과 CSSOM을 결합한다.
    
    화면에 보이는 모든 콘텐츠와 스타일 정보를 모두 포함하는 최종 렌더링 트리를 출력한다
    
    즉, 화면에 표시되는 모든 노드의 콘텐츠 및 스타일 정보를 포함한다
    
3. **Layout (reflow)**
    
    브라우저가 페이지에 표시되는 각 요소의 크기와 위치를 계산한다
    
4. **Paint**
    
    실제 화면에 그린다
    

---

### ‼️ **여기서 문제점**

- 어떤 인터렉션에 의해 DOM에 변화가 발생하면 그때마다 Render Tree가 재생성된다.
Layout, Repaint 과정까지 다시 거치게 되어, 모든 요소들의 스타일을 다시 계산한다.
- 인터렉션이 엄청나게 많아지면 작은 변화로 인해 위에 필요한 과정을 계속 거치게 되니 
불필요하게 DOM을 조작하는 비용이 너무 커진다
- DOM의 변화로 인해 새로운 DOM 객체를 만드는 건 어렵지 않지만, 
Layout 작업 및 Paint 작업은 많은 조작 비용을 필요로 하게 되어,
결국은 성능 상의 문제를 초래한다

**⇒** 😀 이러한 문제로 인해서 나오게 된 것이 **가상 돔 (Virtual Dom)** 이다

### ⬛ 가상 돔 (Virtual DOM)

![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/44c4fa8c359a6b81e2958af647242b25ee6f5270/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/4.png)

- **가상 DOM**: 실제 DOM을 메모리에 복사해준 것
- 가상 돔은 실제 돔과 같은 모양이지만 
Real DOM처럼 직접적으로 브라우저 문서에 접근을 할 수 없다 
그래서 화면에 보이는 요소를 직접 수정할 수도 없다

### ⬛ 가상돔 작동 방식

- 리액트에서는 항상 렌더링 이전의 객체(가상돔)와 렌더링 이후의 객체(가상돔)를 가지고 있다

![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/44c4fa8c359a6b81e2958af647242b25ee6f5270/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/5.png)

- 리액트에서는 어떠한 State(데이터)가 바뀌면 가상돔이 새로 생성된다
- 그리고 이것을 이전에 생긴 가상돔과 비교해서 바뀐 부분만 실제 돔에 적용을 시켜줍니다.
- **Diffing:** 바뀐 부분을 찾는 과정
- **재조정(Reconciliation):** 바뀐 부분만 실제 돔에 적용시켜주는 것

![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/44c4fa8c359a6b81e2958af647242b25ee6f5270/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/6.png)

### ⬛ Reconciliation과 Batch Update

React는 실제 DOM의 메모리 내 가상 표현을 유지하고 배치 업데이트와 동기화를 유지한다. (= 조정)

여기서 리액트는 batch update를 이용해서 싱크를 맞춘다.

- **Batch Update in React.js**
    - State를 업데이트 할 때 한꺼번에 업데이트해줘서 화면이 한번만 다시 그려지게 해준다
        
        ![Untitled](https://raw.githubusercontent.com/damdam6/fe-cs-study-2024/44c4fa8c359a6b81e2958af647242b25ee6f5270/olrlozl/%EB%A6%AC%EC%97%91%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/image/7.png)
        

### ⬛ Real DOM 과 Virtual DOM 비교

10개의 리스트가 있는데 하나의 리스트만 변경시켜줄 때 ?

- **Real DOM**
    
    한 개의 리스트만 업데이트됐지만 전체 리스트를 다시 렌더링 해야한다
    
- **Virtual DOM**
    
    바뀐 한 개의 리스트만 DOM에 업데이트 시켜준다
    
    1. JSX (HTML)을 렌더링 한다. 그러면 Virtual DOM이 Update가 된다
    2. Virtual DOM이 이전 Virtual DOM에서 찍어둔 Snapshot과 비교를 해서 바뀐 부분을 찾는다 (= **diffing**)
    3. 그 바뀐 부분만 Real DOM에서 바꿔준다

### ⬛ 결론

React는 Reconciliation을 통해서 만약 열개의 State데이터가 변한다면 DOM을 열 번 반복해서 조작해주는 것이 아닌, Virtual DOM을 비교해서 한 번의 DOM 조작으로 모든 변화를 반영시켜준다

### ⬛ 정리

1. 리액트의 가상돔은 실제 DOM과 같은 내용을 담고 있으며, 자바스크립트 객체 형태로 메모리에 저장되어 있는 복사본이다.
2. 리액트는 렌더링 이전의 내용을 담고 있는 가상돔과, 변경 이후에 보일 내용을 담고 있는 가상돔을 가지고 있다.
3. 변경이 되기 전 가상돔과 변경이 된 후의 가상돔을 비교하는 과정을 **Diffing** 이라고 한다.
4. Diffing을 통해서 변경된 부분들을 파악한 후, 리액트는 Batch Update를 수행해서 실제 DOM에 한 번에 적용시켜준다. 이러한 과정을 **재조정(Reconciliation)**이라고 한다.
