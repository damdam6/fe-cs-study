# 데이터 타입

### 0. 들어가며
 사실 책을 산지 4개월은 지났다. 먼지 쌓인 코어 자바스크립트 표지의 먼지를 털어냈다. 책을 폈는데 다시 덮을 뻔했다. 이걸 내가 설명을 할 수 가 없다. 설명을 하려면 사실 그냥 책을 복제해서 여기 올려야 함. 하지만, 찬찬히 읽어보면서 이해를 최대한 했으니 설명할 수 있는 범위 내에서 설명할 수 있도록 하겠다. 
 <br/>
 <br/>
 이번 시간에 알아서 가져가야 할 것들로는 데이터 할당 / Garbage Collector 이다.
 
### 1. 데이터 타입의 종류
<img alt="데이터 타입의 종류" width="500px" src="https://twil.weekwith.me/images/2%EA%B8%B0/%EC%A0%95%EC%84%A0%EB%AF%B8/1%EC%A3%BC%EC%B0%A8/1.png" />

기본형과 참조형의 종류로 나뉘어있는 JS의 데이터 타입.
<br/>
기본형 : 값이 담긴 주소값을 바로 복제 (<- 그렇기에 기본형은 **불변성**을 띈다.)
<br/>
참조형 : 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

은수은수야 기본형은 값이 바뀌는데 어떻게 불변성을 띄니.
<br/>
이것을 알기 위해서는 이제 메모리와 데이터에 대한 기본지식이 필요하다. 
<br>(이해를 돕기 위해 진짜 깊은 설명보다는 최대한 알기 쉽게 푸는게 목표)

### 2. 변수 선언과 데이터 할당

```js
var a; //변수 a 선언
a = 'abc' // 변수 a에 데이터 할당

var a = 'abc' // 변수 선언과 할당을 한 문장으로 표현
```
1. var a; : 변수 선언에 대한 메모리 영역의 변화

    | 주소    | ... | 1002   | 1003           | 1004   | ...    |
    |-------|--|--------|----------------|--------|--------|
    | 데이터   |  |  | 이름 : a<br/>값:  |  |  |

잘 따라와야 한다. 만약에 a의 값이 할당 되면 위 표는 2배로 늘어난다. / 추가적으로 실제 메모리 영역을 모두 그리는 것이 아니라 개략적으로 표현 한 것.

2. a='abc'; : 데이터 할당에 대한 메모리 영역의 변화

   | 주소  | ... | 1002  | 1003                | 1004 | ...    |
   |-----|--|-------|---------------------|------|--------|
   | 데이터 |  |       | 이름 : a<br/>값: @5004 |      |  |
    | 주소  | ... | 5002  | 5003                | 5004 | ...    |
   | 데이터 |--|  |     | 'abc' |--------|

1과 2의 차이는 무엇일까? 
<br/> 바로 변수가 만들어지고, 이제 데이터가 할당된 것이다. 여기서부터 잘 따라오면 완벽 이해 가능
<br/>

1) 위의 1번의 1003번 주소에 이름 a와 값을 바로 할당하면 좋겠지만 실제로 해당 위치에 직접 값을 저장하지 않는다.
2) 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고 그 주소를 변수 영역에 @5004 와 같이 저장하는 형식으로 이뤄진다.

이렇게 한 단계 더 거치는 이유 -> **데이터 변환을 자유롭게 하고 동시에 메모리를 효율적으로 관리하기 위함**
<br>만약에 데이터를 위와 같이 하지 않고, '확보된 공간' 안에서만 데이터 변환을 할 수 있다면 변환된 데이터를 다시 저장하기 위해서는 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 이루어져야 하고 이는 비효율적이다.

만약 위의 변수 a가 'abc'의 값이 아니라 'abcdef' 를 할당받게 하고 싶다면, 우리는 5002의 주소에 'abcdef'를 할당하고 다시 그 주소를 변경해주기만 하면 된다.

| 주소  | ... | 1002    | 1003                | 1004 | ...    |
|-----|--|---------|---------------------|------|--------|
| 데이터 |  |         | 이름 : a<br/>값: @5002 |      |  |
| 주소  | ... | 5002    | 5003                | 5004 | ...    |
| 데이터 |--| 'abcdef' |                     | 'abc' |--------|

### 2. 그렇다면 참조형 데이터는?

지금까지 기본형 데이터의 값 할당 방식에 대해 알아봤으니, 참조형 데이터의 할당 방식에 대해서도 알아보자.

```js
var obj1 ={
    a: 1,
    b: 'bbb',
}
```

| 주소  | ... | 1002      | 1003                     | 1004  | ...    |
|-----|--|-----------|--------------------------|-------|--------|
| 데이터 |  |           | 이름 : obj1 <br/> 값: @5002 |       |  |
| 주소  | ... | 5002      | 5003                     | 5004  | ...    |
| 데이터 |--| @7103 ~ ? | 1                        | 'bbb' |--------|

객체 @5002의 변수 영역

| 주소  | 7103                   | 7104                  | 7105 | ...    |
|-----|------------------------|-----------------------|------|--------|
| 데이터 | 이름 : a <br/> 값 : @5003 | 이름 : b <br/> 값: @5004 |      |  |

간단하게 말해서 참조형 데이터의 경우 기본형 데이터와 다르게 **'객체의 변수 영역'** 이 별도로 존재한다는 점이다.
<br/>
보면 @5002 의 영역에 @7103 ~ ? 의 영역이 할당된 것을 확인할 수 있다.

### 3. 한 발자국만 더, 중첩된 참조형 데이터의 할당

```js
var obj = {
    x: 3,
    arr: [3,4,5],
}
```
참조형 데이터 obj 의 프로퍼티에, 다시 참조형 데이터 arr 를 할당했다.

표가 많아졌지만 당황하지 말자 그냥 arr 을 할당할 영역을 추가한 것 뿐이다.

| 주소  | 1001      | 1002                    | 1003 | 1004      | 1005 | ... |
|-------|-----------|-------------------------|------|-----------|------|-----|
| 데이터 |           | 이름: obj <br/> 값 : @5001 |      |           |      |     |
| 주소  | 5001 | 5002                    | 5003 | 5004 | 5005 | ... |
| 데이터 | @7103 ~ ? | 3                       | @8104 ~ ? | 4    | 5    |

**객체 @5001의 변수 영역**

| 주소  | 7103  | 7104  | ... |
|-------|-------|-------|-----|
| 데이터 | 이름: x | 이름: arr |     |
|       | 값: @5002 | 값: @5003 |     |

**배열 @5003의 변수 영역**

| 주소  | 8104  | 8105  | 8106  | ... |
|-------|-------|-------|-------|-----|
| 데이터 | 이름: 0 | 이름: 1 | 이름: 2 |     |
|       | 값: @5002 | 값: @5004 | 값: @5005 |     |

이제 여기서 obj의 arr 을 변경해보자.

```js
obj.arr = 'str';
```

그렇다면 변수 영역들은 아래와 같이 바뀐다.

**그림 1-9 중첩된 참조형 데이터(객체)의 프로퍼티 재할당**

| 주소  | 1001      | 1002                   | 1003               | 1004 | 1005 | 1006 | ... |
|-------|-----------|------------------------|--------------------|------|------|------|-----|
| 데이터 |           | 이름: obj <br/> 값: @5001 |                    |      |      |      |     |
| 주소  | 5001 | 5002                   | 5003  (참조 카운트 : 0) | 5004 | 5005 | 5006  | ... |
| 데이터 | @7103 ~ ? | 3                      | @8104 ~ ?          | 4    | 5    | 'str' |     |

**객체 @5001의 변수 영역**

| 주소  | 7103                | 7104                | ... |
|-------|---------------------|---------------------|-----|
| 데이터 | 이름: x <br/> 값:@5002 | 이름: arr<br/>값:@5006 |     |

**배열 @5003의 변수 영역** (참조 카운트 : 0)

| 주소  | 8104                 | 8105                 | 8106                  | ... |
|-------|----------------------|----------------------|-----------------------|-----|
| 데이터 | 이름: 0 <br/> 값: @5002 | 이름: 1 <br/> 값: @5004 | 이름: 2  <br/> 값: @5005 |     |

사실 바뀌는게 아니라 추가되는거긴 하지만, 여기서 잘 따라와야한다.

이제 obj.arr = 'str' 이다.

기존의 @5003의 영역 그러니까  str로 바뀌기 전의 arr: [3,4,5] 를 저장했던 부분에 주목할 필요가 있다.
<br/>
바로 @5003, 그리고 배열 @5003 의 변수 영역이었던 @8104 ~ ? 의 영역이 그것이다.

### 4. Garbage Collector
GC : 메모리 관리를 자동으로 수행해주는 시스템. 더 이상 사용되지 않는 메모리 공간을 해제 하여 메모리 누수를 방지하고, 프로그램이 사용가능한 메모리 양을 최적화하는데 도움을 준다.

 @5003 은 이제 더 이상 자신의 주소를 참조하는 변수가 하나도 없게 되었다. (arr = 3,4,5 -> str 로 변경되었으므로) 어떤 데이터에서 자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 하는데 str로 변경된 순간 참조 카운트는 0이 되어버렸다.
 
이 때 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다.

이렇듯 Garbage Collector는 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거 한다. 이렇게 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.


++ 추가 Mark-and-Sweep 알고리즘
: 자바 스크립트는 참조 카운팅 외에도 마크 앤 스위프 알고리즘을 주로 사용하기도 한다.

1. 마크(Mark): 실행 중인 모든 객체에서 접근할 수 있는 루트 객체(예: 전역 객체, 현재 함수의 스코프에 있는 변수 등)부터 시작하여, 도달 가능한 모든 객체를 탐색하고 "마크"합니다.
2. 스위프(Sweep): 마크되지 않은 객체들은 도달 불가능한 것으로 간주하여 메모리에서 해제합니다.
이 과정을 통해 자바스크립트 엔진은 사용되지 않는 메모리를 자동으로 정리하여 메모리 누수를 방지하고, 프로그램의 메모리 사용 효율을 높입니다.
